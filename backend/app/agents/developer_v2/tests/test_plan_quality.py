"""Integration tests for Plan Node Quality.

Tests the quality of implementation plans generated by the plan node:
1. Step Ordering - follows layer hierarchy
2. Dependency Quality - valid file paths, no circular deps
3. Interface/Type Rule - receiver before sender

Run with: python -m pytest app/agents/developer_v2/tests/test_plan_quality.py -v -s

Note: These tests call real LLM and cost money. Use sparingly.
"""
import os
import pytest
import pytest_asyncio
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Tuple

from dotenv import load_dotenv
backend_dir = Path(__file__).parent.parent.parent.parent.parent
load_dotenv(backend_dir / ".env")

# Configure pytest-asyncio
pytest_plugins = ('pytest_asyncio',)

pytestmark = [
    pytest.mark.skipif(
        not os.getenv("ANTHROPIC_API_KEY") and not os.getenv("OPENAI_API_KEY"),
        reason="No API key found"
    ),
    pytest.mark.asyncio
]


# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

def get_layer_priority(file_path: str) -> int:
    """Get layer priority for a file path.
    
    Lower number = should come first.
    
    Layer 1: prisma/schema.prisma (database)
    Layer 2: src/types/** (TypeScript types)
    Layer 3: src/lib/** (utilities)
    Layer 4: src/app/api/** (API routes)
    Layer 5: src/app/actions/** (Server Actions)
    Layer 6: src/components/** (Components)
    Layer 7: src/app/**/page.tsx (Pages - ALWAYS LAST)
    """
    path = file_path.replace("\\", "/").lower()
    
    # Layer 1: Database
    if "prisma" in path and "schema" in path:
        return 1
    if "prisma/seed" in path:
        return 1
    
    # Layer 2: Types
    if "/types/" in path or path.endswith(".d.ts"):
        return 2
    
    # Layer 3: Lib/Utils
    if "/lib/" in path or "/utils/" in path or "/hooks/" in path:
        return 3
    
    # Layer 4: API Routes
    if "/api/" in path and "route.ts" in path:
        return 4
    
    # Layer 5: Server Actions
    if "/actions/" in path:
        return 5
    
    # Layer 7: Pages (check before components!)
    if "page.tsx" in path or "page.ts" in path:
        return 7
    
    # Layer 6: Components
    if "/components/" in path:
        return 6
    
    # Default: treat as component level
    return 6


def check_ordering_violations(plan: List[Dict]) -> List[Tuple[int, int, str]]:
    """Check for layer ordering violations.
    
    Returns list of (step_index, violating_step_index, reason).
    """
    violations = []
    
    for i, step in enumerate(plan):
        file_path = step.get("file_path", "")
        current_layer = get_layer_priority(file_path)
        
        # Check if any later step has lower layer priority
        for j in range(i + 1, len(plan)):
            later_file = plan[j].get("file_path", "")
            later_layer = get_layer_priority(later_file)
            
            if later_layer < current_layer:
                violations.append((
                    i + 1,  # 1-indexed
                    j + 1,
                    f"Step {i+1} ({file_path}, layer {current_layer}) comes before "
                    f"Step {j+1} ({later_file}, layer {later_layer})"
                ))
    
    return violations


def check_dependency_violations(plan: List[Dict]) -> List[Tuple[int, str]]:
    """Check for dependency violations.
    
    Returns list of (step_index, reason).
    """
    violations = []
    created_files = set()
    
    for i, step in enumerate(plan):
        file_path = step.get("file_path", "")
        deps = step.get("dependencies", [])
        
        for dep in deps:
            # Check: dependency should be string
            if not isinstance(dep, str):
                violations.append((i + 1, f"Invalid dep type: {type(dep).__name__} ({dep})"))
                continue
            
            # Check: dependency should look like a file path
            if dep and "/" not in dep and "." not in dep:
                violations.append((i + 1, f"Suspicious dep (not a path?): {dep}"))
        
        # Add current file to created set
        if file_path:
            created_files.add(file_path)
    
    return violations


def check_circular_dependencies(plan: List[Dict]) -> List[Tuple[int, int, str]]:
    """Check for circular dependencies.
    
    Returns list of (step_a, step_b, reason).
    """
    violations = []
    
    # Build dependency map
    step_deps = {}
    for i, step in enumerate(plan):
        file_path = step.get("file_path", "")
        deps = step.get("dependencies", [])
        if file_path:
            step_deps[file_path] = [d for d in deps if isinstance(d, str)]
    
    # Check for circular deps
    for file_a, deps_a in step_deps.items():
        for dep in deps_a:
            if dep in step_deps:
                deps_of_dep = step_deps.get(dep, [])
                if file_a in deps_of_dep:
                    # Find step indices
                    idx_a = next((i for i, s in enumerate(plan) if s.get("file_path") == file_a), -1)
                    idx_b = next((i for i, s in enumerate(plan) if s.get("file_path") == dep), -1)
                    violations.append((
                        idx_a + 1, idx_b + 1,
                        f"Circular: {file_a} <-> {dep}"
                    ))
    
    return violations


def calculate_ordering_score(plan: List[Dict]) -> float:
    """Calculate ordering quality score (0-100).
    
    100 = perfect ordering, no violations.
    """
    if not plan:
        return 100.0
    
    violations = check_ordering_violations(plan)
    max_violations = len(plan) * (len(plan) - 1) / 2  # Max possible pairs
    
    if max_violations == 0:
        return 100.0
    
    score = 100 * (1 - len(violations) / max_violations)
    return max(0, score)


def calculate_dependency_score(plan: List[Dict]) -> float:
    """Calculate dependency quality score (0-100).
    
    100 = all steps have valid dependencies.
    """
    if not plan:
        return 100.0
    
    violations = check_dependency_violations(plan)
    circular = check_circular_dependencies(plan)
    
    total_issues = len(violations) + len(circular)
    score = 100 * (1 - total_issues / len(plan))
    return max(0, score)


# =============================================================================
# TEST STORIES
# =============================================================================

STORY_HOMEPAGE = {
    "story_id": "TEST-001",
    "story_title": "Homepage with Featured Books",
    "story_description": "Create homepage with hero section, featured books grid, and category navigation.",
    "story_requirements": [
        "Display hero section with featured books carousel",
        "Show bestsellers section with top 8 books",
        "Display book cards with cover, title, author, price",
        "Include category navigation menu",
    ],
    "acceptance_criteria": [
        "Given I visit homepage, When page loads, Then I see hero and book sections",
    ],
}

STORY_SEARCH = {
    "story_id": "TEST-002",
    "story_title": "Search Books API and UI",
    "story_description": "Implement search functionality with API and autocomplete UI.",
    "story_requirements": [
        "Create search API endpoint accepting query parameter",
        "Search across book title, author, ISBN",
        "Return paginated results with book details",
        "Display search results in grid layout",
    ],
    "acceptance_criteria": [
        "Given I search 'harry', When results load, Then I see matching books",
    ],
}

STORY_CRUD = {
    "story_id": "TEST-003",
    "story_title": "Book Management CRUD",
    "story_description": "Full CRUD for books with database model, API, and admin UI.",
    "story_requirements": [
        "Create Book model in Prisma with title, author, price, stock",
        "Create API routes for GET, POST, PUT, DELETE",
        "Create admin page to list and manage books",
        "Include form validation and error handling",
    ],
    "acceptance_criteria": [
        "Given I am admin, When I create a book, Then it appears in the list",
    ],
}


# =============================================================================
# TEST FIXTURES
# =============================================================================

@pytest.fixture
def workspace(tmp_path):
    """Create workspace with basic Next.js structure."""
    ws = tmp_path / "test_workspace"
    ws.mkdir()
    
    # Create directories
    (ws / "src" / "app" / "api").mkdir(parents=True)
    (ws / "src" / "components").mkdir(parents=True)
    (ws / "src" / "lib").mkdir(parents=True)
    (ws / "src" / "types").mkdir(parents=True)
    (ws / "prisma").mkdir()
    
    # Create minimal files
    (ws / "prisma" / "schema.prisma").write_text("""
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Book {
  id        String   @id @default(uuid())
  title     String
  author    String
  price     Float
  createdAt DateTime @default(now())
}
""")
    
    (ws / "src" / "lib" / "prisma.ts").write_text("""
import { PrismaClient } from '@prisma/client'
export const prisma = new PrismaClient()
""")
    
    (ws / "src" / "types" / "index.ts").write_text("""
export interface BookCardData {
  id: string;
  title: string;
  author: string;
  price: number;
  coverUrl?: string;
}
""")
    
    return ws


def create_state(workspace, story: Dict) -> Dict:
    """Create test state from story."""
    return {
        "workspace_path": str(workspace),
        "project_id": "test-project",
        "task_id": story["story_id"],
        "tech_stack": "nextjs",
        "story_id": story["story_id"],
        "story_title": story["story_title"],
        "story_description": story["story_description"],
        "story_requirements": story["story_requirements"],
        "acceptance_criteria": story["acceptance_criteria"],
        "files_modified": [],
    }


# =============================================================================
# TEST CLASSES
# =============================================================================

class TestStepOrdering:
    """Test that plan steps follow correct layer ordering."""
    
    @pytest.mark.asyncio
    async def test_layer_order_homepage(self, workspace):
        """Homepage story: components should come before pages."""
        from app.agents.developer_v2.src.nodes.plan import plan
        from app.agents.developer_v2.src.tools import set_tool_context
        
        state = create_state(workspace, STORY_HOMEPAGE)
        set_tool_context(str(workspace), state["project_id"], state["task_id"])
        
        result = await plan(state)
        steps = result.get("implementation_plan", [])
        
        print(f"\n{'='*60}")
        print(f"STORY: {STORY_HOMEPAGE['story_title']}")
        print(f"{'='*60}")
        print(f"Generated {len(steps)} steps:\n")
        
        for i, step in enumerate(steps):
            fp = step.get("file_path", "")
            layer = get_layer_priority(fp)
            print(f"  {i+1}. [L{layer}] {fp}")
        
        # Check violations
        violations = check_ordering_violations(steps)
        
        if violations:
            print(f"\n[WARN] Ordering violations ({len(violations)}):")
            for v in violations[:5]:  # Show first 5
                print(f"  - {v[2]}")
        
        score = calculate_ordering_score(steps)
        print(f"\n[SCORE] Ordering: {score:.0f}/100")
        
        # Pages should be in last 30% of steps
        page_indices = [i for i, s in enumerate(steps) if "page.tsx" in s.get("file_path", "")]
        if page_indices and steps:
            last_30_percent = len(steps) * 0.7
            pages_in_last_30 = all(i >= last_30_percent for i in page_indices)
            print(f"[CHECK] Pages in last 30%: {pages_in_last_30}")
        
        assert score >= 70, f"Ordering score {score:.0f} < 70"
    
    @pytest.mark.asyncio
    async def test_layer_order_crud(self, workspace):
        """CRUD story: database → types → API → components → pages."""
        from app.agents.developer_v2.src.nodes.plan import plan
        from app.agents.developer_v2.src.tools import set_tool_context
        
        state = create_state(workspace, STORY_CRUD)
        set_tool_context(str(workspace), state["project_id"], state["task_id"])
        
        result = await plan(state)
        steps = result.get("implementation_plan", [])
        
        print(f"\n{'='*60}")
        print(f"STORY: {STORY_CRUD['story_title']}")
        print(f"{'='*60}")
        print(f"Generated {len(steps)} steps:\n")
        
        for i, step in enumerate(steps):
            fp = step.get("file_path", "")
            layer = get_layer_priority(fp)
            deps = step.get("dependencies", [])
            print(f"  {i+1}. [L{layer}] {fp}")
            if deps:
                print(f"       deps: {deps[:3]}{'...' if len(deps) > 3 else ''}")
        
        # Check violations
        violations = check_ordering_violations(steps)
        score = calculate_ordering_score(steps)
        
        print(f"\n[VIOLATIONS] {len(violations)}")
        print(f"[SCORE] Ordering: {score:.0f}/100")
        
        # Database should be first if present
        db_steps = [i for i, s in enumerate(steps) if "prisma" in s.get("file_path", "").lower()]
        if db_steps:
            print(f"[CHECK] Database step at position: {db_steps[0] + 1}")
            assert db_steps[0] <= 2, "Database should be in first 2 steps"
        
        assert score >= 60, f"Ordering score {score:.0f} < 60"


class TestDependencyQuality:
    """Test that dependencies are valid and well-declared."""
    
    @pytest.mark.asyncio
    async def test_dependencies_are_strings(self, workspace):
        """All dependencies should be file path strings."""
        from app.agents.developer_v2.src.nodes.plan import plan
        from app.agents.developer_v2.src.tools import set_tool_context
        
        state = create_state(workspace, STORY_HOMEPAGE)
        set_tool_context(str(workspace), state["project_id"], state["task_id"])
        
        result = await plan(state)
        steps = result.get("implementation_plan", [])
        
        print(f"\n{'='*60}")
        print("DEPENDENCY TYPE CHECK")
        print(f"{'='*60}\n")
        
        invalid_deps = []
        for i, step in enumerate(steps):
            deps = step.get("dependencies", [])
            for dep in deps:
                if not isinstance(dep, str):
                    invalid_deps.append((i + 1, step.get("file_path", ""), dep, type(dep).__name__))
        
        if invalid_deps:
            print("[FAIL] Non-string dependencies found:")
            for idx, fp, dep, typ in invalid_deps:
                print(f"  Step {idx} ({fp}): {dep} ({typ})")
        else:
            print("[PASS] All dependencies are strings")
        
        assert len(invalid_deps) == 0, f"Found {len(invalid_deps)} non-string dependencies"
    
    @pytest.mark.asyncio
    async def test_no_circular_dependencies(self, workspace):
        """No circular dependencies between steps."""
        from app.agents.developer_v2.src.nodes.plan import plan
        from app.agents.developer_v2.src.tools import set_tool_context
        
        state = create_state(workspace, STORY_SEARCH)
        set_tool_context(str(workspace), state["project_id"], state["task_id"])
        
        result = await plan(state)
        steps = result.get("implementation_plan", [])
        
        print(f"\n{'='*60}")
        print("CIRCULAR DEPENDENCY CHECK")
        print(f"{'='*60}\n")
        
        circular = check_circular_dependencies(steps)
        
        if circular:
            print("[FAIL] Circular dependencies found:")
            for a, b, reason in circular:
                print(f"  {reason}")
        else:
            print("[PASS] No circular dependencies")
        
        assert len(circular) == 0, f"Found {len(circular)} circular dependencies"
    
    @pytest.mark.asyncio
    async def test_dependency_coverage(self, workspace):
        """Steps with imports should declare dependencies."""
        from app.agents.developer_v2.src.nodes.plan import plan
        from app.agents.developer_v2.src.tools import set_tool_context
        
        state = create_state(workspace, STORY_HOMEPAGE)
        set_tool_context(str(workspace), state["project_id"], state["task_id"])
        
        result = await plan(state)
        steps = result.get("implementation_plan", [])
        
        print(f"\n{'='*60}")
        print("DEPENDENCY COVERAGE CHECK")
        print(f"{'='*60}\n")
        
        # Count steps with and without dependencies
        steps_with_deps = sum(1 for s in steps if s.get("dependencies"))
        total_steps = len(steps)
        
        # Pages and components should have dependencies
        expected_with_deps = sum(
            1 for s in steps 
            if "page.tsx" in s.get("file_path", "") or "/components/" in s.get("file_path", "")
        )
        
        coverage = steps_with_deps / total_steps * 100 if total_steps > 0 else 0
        
        print(f"Steps with dependencies: {steps_with_deps}/{total_steps} ({coverage:.0f}%)")
        print(f"Pages/Components (should have deps): {expected_with_deps}")
        
        # At least 50% of steps should have dependencies
        assert coverage >= 40, f"Dependency coverage {coverage:.0f}% < 40%"


class TestInterfaceTypeRule:
    """Test receiver-before-sender rule."""
    
    @pytest.mark.asyncio
    async def test_components_before_pages(self, workspace):
        """Components should be defined before pages that use them."""
        from app.agents.developer_v2.src.nodes.plan import plan
        from app.agents.developer_v2.src.tools import set_tool_context
        
        state = create_state(workspace, STORY_HOMEPAGE)
        set_tool_context(str(workspace), state["project_id"], state["task_id"])
        
        result = await plan(state)
        steps = result.get("implementation_plan", [])
        
        print(f"\n{'='*60}")
        print("COMPONENT → PAGE ORDER CHECK")
        print(f"{'='*60}\n")
        
        # Find component and page indices
        component_indices = {}
        page_indices = {}
        
        for i, step in enumerate(steps):
            fp = step.get("file_path", "")
            if "/components/" in fp:
                name = fp.split("/")[-1].replace(".tsx", "")
                component_indices[name] = i
            elif "page.tsx" in fp:
                page_indices[fp] = i
        
        print(f"Components: {list(component_indices.keys())}")
        print(f"Pages: {list(page_indices.keys())}")
        
        # Check: all components should come before all pages
        violations = []
        if component_indices and page_indices:
            max_component_idx = max(component_indices.values())
            min_page_idx = min(page_indices.values())
            
            if max_component_idx >= min_page_idx:
                violations.append(f"Component at step {max_component_idx + 1} comes after page at step {min_page_idx + 1}")
        
        if violations:
            print(f"\n[WARN] Violations:")
            for v in violations:
                print(f"  - {v}")
        else:
            print("\n[PASS] All components come before pages")
        
        # Allow some violations but not many
        assert len(violations) <= 1, f"Too many violations: {violations}"


class TestPlanMetrics:
    """Test overall plan quality metrics."""
    
    @pytest.mark.asyncio
    async def test_overall_quality_score(self, workspace):
        """Calculate and report overall quality score."""
        from app.agents.developer_v2.src.nodes.plan import plan
        from app.agents.developer_v2.src.tools import set_tool_context
        
        stories = [STORY_HOMEPAGE, STORY_SEARCH, STORY_CRUD]
        results = []
        
        print(f"\n{'='*60}")
        print("OVERALL QUALITY METRICS")
        print(f"{'='*60}\n")
        
        for story in stories:
            state = create_state(workspace, story)
            set_tool_context(str(workspace), state["project_id"], state["task_id"])
            
            start = datetime.now()
            result = await plan(state)
            elapsed = (datetime.now() - start).total_seconds()
            
            steps = result.get("implementation_plan", [])
            
            ordering_score = calculate_ordering_score(steps)
            dep_score = calculate_dependency_score(steps)
            overall = (ordering_score + dep_score) / 2
            
            results.append({
                "story": story["story_title"][:30],
                "steps": len(steps),
                "ordering": ordering_score,
                "deps": dep_score,
                "overall": overall,
                "time": elapsed,
            })
            
            print(f"Story: {story['story_title'][:40]}")
            print(f"  Steps: {len(steps)}, Time: {elapsed:.1f}s")
            print(f"  Ordering: {ordering_score:.0f}, Deps: {dep_score:.0f}, Overall: {overall:.0f}")
            print()
        
        # Summary
        avg_ordering = sum(r["ordering"] for r in results) / len(results)
        avg_deps = sum(r["deps"] for r in results) / len(results)
        avg_overall = sum(r["overall"] for r in results) / len(results)
        
        print(f"{'='*60}")
        print(f"AVERAGE SCORES")
        print(f"{'='*60}")
        print(f"Ordering: {avg_ordering:.0f}/100")
        print(f"Dependencies: {avg_deps:.0f}/100")
        print(f"Overall: {avg_overall:.0f}/100")
        
        assert avg_overall >= 60, f"Average quality score {avg_overall:.0f} < 60"
